import * as c from 'node-canvas';
import * as fs from 'fs';
import bar from 'quick-progress-bar'; // My own package, it's a really easy progress bar system
/*
* Fairly simple wallpaper generator, but it looks pretty cool and I like it a lot.
* Colors are generated by getting the distance left, center, and right, and multiplying each to get the final value.
* So if we are 100% left, and the value is {r: 0, g: 1, b: 0}, then we get a full green color
* Value of r looks like this:
* (1 - x / canvas.width) * left.r
* (x / canvas.width) * right.r
* (1 - distFromCenter) * center.r
* (1 - x / canvas.width) gets a value between 0 and 1 representing the left position, by getting right position between 0 and 1 and inverting it.
* (x / canvas.width) gets a value between 0 and 1 representing the right position by dividing x by canvas.width.
* distFromCenter is calculated with Math.abs(x - canvas.width / 2) / (canvas.width / 2);
* It seems complicated, but I'll break it down:
* Math.abs(x - canvas.width / 2) essentially just gets the distance from the center of the canvas to the current x position, by changing it from basically
0 < x < 1 to -0.5 < x < 0.5.
* / (canvas.width / 2) simply makes it a value between 0 and 1 so we can use it easier. We have the / 2 because obviously -0.5 < x < 0.5's values are going to be ~half of 0 < x < 1
* A 'unit' is the height / 30, remember that when I refer to unit.
* We then loop 60 times because it means that it is physically impossble for us to have too few lines, as we have 30 lines on top. I don't fully understand it, but it works, so IDC.
* We can get the x starting position with 'canvas.width / 2 - (canvas.height / 15) * i - canvas.height / 30;'
* It's fairly simple, but I'll explain it anyway.
* It subtracts i * 2 units from the middle of the canvas, so that for each i increase, it moves 2 units to the left.
* We also correct position a bit by subtracting a unit. I don't fully understand why it works either, but it works.
* We also do an additional -1 unit, but only after the opposite x is generated, so that it looks mirrored. I don't know why it works, but it does, so you don't hear me complaining.
* If it goes below -2 units, it starts moving the y start position-- This is not needed for operation, but it makes it faster to generate, as it allows it to start just offscreen.
* The opposite side's starting position is literally just an inverse of the first side's starting position.
* If the first starting x position is less than -2 units, then y position is the starting x position - half view width - 2 units (for correction). This allows us to move up rather than out
and stay offscreen.
* We can glide to a position with a simple while loop. While(Math.abs(x) != Math.abs(ex) || Math.abs(y) != Math.abs(ey))...
* We generate a square at the x and y position.
* Then, if x != ex, then we move x by the sign of ex - x, so that we move closer to ex.
* The same for y, if y != ey, we move y by the sign of ey - y, so that we move closer to ey.
* That's it. Fairly simple code, but it was fun to write.
* Liscence: MIT
* Author: github.com/Oman395, Oran RH
*/
const canvas = new c.Canvas(1920, 1080);
const ctx = canvas.getContext('2d');
canvas.width = 1920;
canvas.height = 1080;
let left = { // Values are between 0 and 1
    r: 1,
    g: 0,
    b: 0
}
let center = {
    r: 0,
    g: 0,
    b: 1
}
let right = {
    r: 0,
    g: 1,
    b: 0
}
function getInput(prompt) {
    return new Promise(resolve => {
        process.stdout.write(prompt);
        process.stdin.once('data', data => resolve(data.toString().trim()));
    });
}
let bleed = 0.5;
function getColor(x) {
    x /= canvas.width;
    let distFromLeft = (-2 * x + 1) ** bleed;
    distFromLeft = isNaN(distFromLeft) ? 0 : distFromLeft;
    let distFromRight = (2 * x - 1) ** bleed;
    distFromRight = isNaN(distFromRight) ? 0 : distFromRight;
    let distFromCenter = 1 - Math.abs(distFromRight - distFromLeft) / 2;
    distFromLeft = distFromLeft < 0 ? 0 : distFromLeft;
    distFromRight = distFromRight < 0 ? 0 : distFromRight;
    distFromCenter = distFromCenter < 0 ? 0 : distFromCenter;
    distFromLeft = distFromLeft > 1 ? 1 : distFromLeft;
    distFromRight = distFromRight > 1 ? 1 : distFromRight;
    distFromCenter = distFromCenter > 1 ? 1 : distFromCenter
    let leftR = distFromLeft * left.r;
    let centerR = distFromCenter * center.r;
    let rightR = distFromRight * right.r;
    let leftG = distFromLeft * left.g;
    let centerG = distFromCenter * center.g;
    let rightG = distFromRight * right.g;
    let leftB = distFromLeft * left.b;
    let centerB = distFromCenter * center.b;
    let rightB = distFromRight * right.b;
    let r = leftR + centerR + rightR;
    let g = leftG + centerG + rightG;
    let b = leftB + centerB + rightB;
    r = r > 1 ? 1 : r;
    g = g > 1 ? 1 : g;
    b = b > 1 ? 1 : b;
    return { r, g, b };
}

async function glideToPos(sx, sy, ex, ey) {
    return new Promise(async res => {
        for (let x = sx, y = sy; Math.round(x) != Math.round(ex) || Math.round(y) != Math.round(ey); x, y) {
            await new Promise(res => {
                ctx.beginPath();
                let color = getColor(x, y);
                Object.keys(color).forEach(c => color[c] = color[c] < 0 ? 0 : Math.round(color[c] * 255) / 255);
                let gradient = ctx.createLinearGradient(x, y, x, y + canvas.height / 30);
                try {
                    gradient.addColorStop(0, `#${Math.round(color.r * 255).toString(16).padStart(2, '0')}${Math.round(color.g * 255).toString(16).padStart(2, '0')}${Math.round(color.b * 255).toString(16).padStart(2, '0')}`);
                    gradient.addColorStop(0.8, `#${Math.round(color.r * 255).toString(16).padStart(2, '0')}${Math.round(color.g * 255).toString(16).padStart(2, '0')}${Math.round(color.b * 255).toString(16).padStart(2, '0')}`);
                    color.r /= 1.2;
                    color.g /= 1.2;
                    color.b /= 1.2;
                    gradient.addColorStop(1, `#${Math.round(color.r * 255).toString(16).padStart(2, '0')}${Math.round(color.g * 255).toString(16).padStart(2, '0')}${Math.round(color.b * 255).toString(16).padStart(2, '0')}`);
                } catch {
                    throw new Error(`Failed color: ${color.r},${color.g},${color.b}`);
                }
                ctx.fillStyle = gradient;
                let mod = 1;
                ctx.fillRect(x, y, canvas.height / 30 + mod, canvas.height / 30);
                if (Math.round(x) != Math.round(ex)) x += Math.sign(ex - x);
                if (Math.round(y) != Math.round(ey)) y += Math.sign(ey - y);
                res();
            });
        }
        res();
    });
}

function sleep(ms) { // Usefull function to have in basically any code, I recommend it.
    return new Promise(resolve => setTimeout(resolve, ms));
}
async function doIt() {
    const b = new bar.bar();
    let count = 30;
    count = canvas.width / canvas.height > 2 ? 30 + Math.round((canvas.width - canvas.height * 2) / (canvas.height / 7.5)) : count;
    b.addBar('Progress', `lines`, 0, count);
    for (let i = 0; i < count; i++) {
        await new Promise(async res => {
            let x1 = canvas.width / 2 - (canvas.height / 15) * i - canvas.height / 30;
            let ys = x1 > -canvas.height / 15 ? 0 : Math.abs(x1) - canvas.height / 15;
            x1 = x1 < -canvas.height / 15 ? -canvas.height / 15 : x1;
            let x2 = canvas.width - x1;
            x1 -= canvas.height / 30; // Doing this after b/c it makes x2 easier to generate, b/c for whatever reason it fucks with the inversion
            let y = i * (canvas.height / 30);
            ys = ys - canvas.height / 30 > y ? y : ys;
            await glideToPos(x1, -canvas.height / 30 + ys, canvas.width / 2 - canvas.height / 60 + 1, y);
            await glideToPos(x2, -canvas.height / 30 + ys, canvas.width / 2 - canvas.height / 60 - 1, y);
            b.update(i + 1, count, 'Progress');
            let buffer = canvas.toBuffer();
            fs.writeFile('output.png', buffer, res);
        });
    }
    let buffer = canvas.toBuffer();
    fs.writeFileSync('output.png', buffer);
}

(async () => { // Shitty ass code to get the user input, but it works
    await getInput('Enter width: ')
        .then(r => {
            canvas.width = parseInt(r);
        });
    await getInput('Enter height: ')
        .then(r => {
            canvas.height = parseInt(r);
        });
    console.log('Enter RGB values for the sides, between 0 and 1, where 0 is no color and 1 is full.');
    await getInput('Enter left R: ')
        .then(r => {
            left.r = parseFloat(r);
        });
    await getInput('Enter left G: ')
        .then(g => {
            left.g = parseFloat(g);
        });
    await getInput('Enter left B: ')
        .then(b => {
            left.b = parseFloat(b);
        });
    await getInput('Enter center R: ')
        .then(r => {
            center.r = parseFloat(r);
        });
    await getInput('Enter center G: ')
        .then(g => {
            center.g = parseFloat(g);
        });
    await getInput('Enter center B: ')
        .then(b => {
            center.b = parseFloat(b);
        });
    await getInput('Enter right R: ')
        .then(r => {
            right.r = parseFloat(r);
        });
    await getInput('Enter right G: ')
        .then(g => {
            right.g = parseFloat(g);
        });
    await getInput('Enter right B: ')
        .then(b => {
            right.b = parseFloat(b);
        });
    await getInput('Center color spread, -1 to 15 (I recommend 0.2 for large monitors, and -0.1 for small ones :D): ')
        .then(b => {
            bleed = 1 + 0.4 * parseFloat(b);
        });
    doIt();
})();

process.on('uncaughtException', async err => { // Mostly used for debugging packaging into an executable, so that I can view errors b4 the window closes.
    console.error(err);
    await sleep(1000);
    fs.writeFileSync('err.txt', err.toString());
    process.exit();
});